# -*- coding: utf-8 -*-
"""compute_statistics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NzwEfTzTJrRYsJicKoojum2eoeF96LAj

# Ejercicio de programación 1: Compute statistics
"""

import random
import time
import inspect

# --- Generar datos ---
def generate_test_data(filename="data_exercise_1.txt", count=1000):
    """Genera un archivo con N números aleatorios y algunos errores para pruebas."""
    with open(filename, 'w', encoding='utf-8') as f:
        for _ in range(count):
            # Requerimiento 6: Manejar miles de items
            f.write(f"{random.uniform(1, 1000):.2f}\n")
        # Requerimiento 3: Datos inválidos para manejo de errores
        f.write("DATO_INVALIDO\n")
        f.write("error_99\n")
    print(f"Archivo '{filename}' generado con {count} registros.")

# --- PROGRAMA PRINCIPAL: compute_statistics.py ---
def compute_statistics(file_path):
    """
    Calcula estadísticas descriptivas sin librerías externas.
    Cumple con Req 1 al Req 8.
    """
    start_time = time.time() # Req 7
    numbers = []

    # Requerimiento 3: Manejo de datos inválidos
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            for line in file:
                try:
                    numbers.append(float(line.strip()))
                except ValueError:
                    print(f"Error de dato: '{line.strip()}' no es numérico.")
    except FileNotFoundError:
        print(f"Error: El archivo {file_path} no existe.")
        return

    if not numbers:
        return

    # --- Algoritmos Básicos  ---
    n = len(numbers)

    # Media
    mean = sum(numbers) / n

    # Mediana (Ordenamiento manual - Bubble Sort)
    sorted_nums = numbers[:]
    for i in range(n):
        for j in range(0, n - i - 1):
            if sorted_nums[j] > sorted_nums[j + 1]:
                sorted_nums[j], sorted_nums[j + 1] = sorted_nums[j + 1], sorted_nums[j]

    if n % 2 == 0:
        median = (sorted_nums[n // 2 - 1] + sorted_nums[n // 2]) / 2
    else:
        median = sorted_nums[n // 2]

    # Moda
    counts = {}
    for num in numbers:
        counts[num] = counts.get(num, 0) + 1
    max_freq = max(counts.values())
    mode = [k for k, v in counts.items() if v == max_freq][0]

    # Varianza y Desviación Estándar
    variance = sum((x - mean) ** 2 for x in numbers) / n
    std_dev = variance ** 0.5

    end_time = time.time()
    elapsed_time = end_time - start_time # Req 7

    # --- Formateo de Resultados ---
    results = (
        f"--- Estadísticas --- \n"
        f"Media: {mean:.4f}\n"
        f"Mediana: {median:.4f}\n"
        f"Moda: {mode:.4f}\n"
        f"Varianza: {variance:.4f}\n"
        f"Desviación Estándar: {std_dev:.4f}\n"
        f"Tiempo transcurrido: {elapsed_time:.6f} s\n"
    )

    # Imprimir en pantalla y guardar en archivo (Req 2)
    print(results)
    with open("StatisticsResults.txt", "w", encoding='utf-8') as out_file:
        out_file.write(results)

# --- EJECUCIÓN ---
# 1. Generamos los datos
generate_test_data()

# 2. Ejecutamos el análisis
compute_statistics("data_exercise_1.txt")

!pip install pylint

# Capturamos el código de la función compute_statistics directamente.
compute_statistics_code = inspect.getsource(compute_statistics)

# Añadimos el import necesario al inicio del archivo que pylint leerá
compute_statistics_file_content = '"""Módulo para calcular estadísticas descriptivas."""\n# pylint: disable=R0914\nimport time\n\n' + compute_statistics_code

# Aseguramos que el contenido termine con una nueva línea
if not compute_statistics_file_content.endswith('\n'):
    compute_statistics_file_content += '\n'

# Creamos el archivo físico para que pylint lo lea
with open("compute_statistics.py", "w") as f:
    f.write(compute_statistics_file_content)

!pylint compute_statistics.py